---
title: Subagents
description: Delegate focused work without polluting your main context.
duration: 30m
module: Power Features
order: 8
---

import { SubagentSplitContext } from "@/components/visuals/SubagentSplitContext"

## What Subagents Are

Subagents are specialized Claude instances with their own context window, prompt, model, and tool rules. They run a focused task, then return a summary to your main session.

<SubagentSplitContext />

<InlineTOC />

## Subagents vs Agent Teams

Both are useful. The decision is about communication.

| Need | Use |
| :-- | :-- |
| One focused worker that reports back | Subagent |
| Multiple workers that need to talk to each other | Agent team |
| Lower token overhead | Subagent |
| Cross-role collaboration (research + architecture + critique) | Agent team |

Rule of thumb:
- Use subagents by default
- Move to agent teams when peer-to-peer collaboration is required

## Built-In Subagents You Should Know

Claude Code already includes built-ins you will see often:

- `Explore`: fast, read-only codebase exploration
- `Plan`: read-only research while you're in plan mode
- `general-purpose`: full capability for complex multi-step execution

This matters because delegation already happens under the hood. Custom subagents should fill gaps, not duplicate these roles.

## Create a Team-Ready Subagent

Use `/agents` for the fastest setup, then tighten scope:

1. Choose scope: project (`.claude/agents/`) for shared team workflows, user (`~/.claude/agents/`) for personal helpers
2. Write a precise description so Claude delegates correctly
3. Restrict tools and permission mode aggressively
4. Set model intentionally (`haiku`, `sonnet`, `opus`, or `inherit`)

Example project subagent:

```markdown
---
name: api-reviewer
description: Reviews API changes for auth, validation, and error handling
tools: Read, Glob, Grep
model: sonnet
permissionMode: plan
skills:
  - api-conventions
memory: project
---

You are a strict API reviewer.
Focus on security boundaries, schema consistency, and regression risk.
Return concise findings with file paths and suggested fixes.
```

## Guardrails That Keep Agents Useful

- Keep each subagent narrow in purpose
- Prefer read-only tools unless edits are required
- Use `memory: project` when the agent should learn team conventions over time
- Check project subagents into git so the whole team gets consistent behavior

## Key Takeaways

- Subagents are your default delegation tool for focused tasks
- Agent teams are better when workers must coordinate directly
- Tool limits, model choice, and permission mode define subagent quality
