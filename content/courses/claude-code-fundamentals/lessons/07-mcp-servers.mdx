---
title: MCP Servers
description: Extend Claude Code with tools - without blowing up your context.
duration: 30m
module: Core Features
order: 7
---

import { McpArchitectureMap } from "@/components/visuals/McpArchitectureMap"
import { McpBloatMeter } from "@/components/visuals/McpBloatMeter"

<InlineTOC />

## The Plugin System You Didn't Know You Had

Imagine if your code editor could talk to your database. Not through a terminal window you switch to, but directly -- querying tables, reading schemas, and writing migrations as part of the same conversation where you're building a feature.

That's what **MCP** (Model Context Protocol) does for Claude Code. It's a standardized way to connect external tools -- databases, browsers, APIs, file systems, design tools -- so Claude can use them natively.

But there's a catch. Every tool you connect costs context space, even when you're not using it. The art of MCP is knowing **what to connect and what to leave disconnected**.

## How MCP Actually Works

The architecture is simpler than it sounds:

<McpArchitectureMap />

Your Claude Code session talks to **MCP servers** -- small programs that each expose a set of tools. When you ask Claude to "check the database schema," it calls a tool on the database MCP server, gets the result, and uses it in its response.

Each server runs as a separate process. Claude Code manages the connections. You just tell it which servers to enable.

<Callout title="Key Insight">
MCP servers are like browser extensions. Each one adds capability, but too many slow everything down. Be intentional about what you install.
</Callout>

## The Context Cost Problem

Here's what trips people up: **every enabled MCP server adds its tool definitions to your context**, whether you use those tools or not. Three servers might add 2,000 tokens of tool descriptions before you've even typed a prompt.

<McpBloatMeter />

This matters because context is a budget. Tool descriptions that sit unused are wasting space that could hold your actual code.

The practical rule: **enable 2-4 servers per project.** If a task can be handled with a built-in tool or a shell command, prefer that over adding another MCP server.

## Managing Servers

From the terminal, you can manage servers with these commands:

```bash
# Add a new server
claude mcp add my-server npx @example/mcp-server

# List all configured servers
claude mcp list

# Check a specific server's config
claude mcp get my-server

# Remove a server you no longer need
claude mcp remove my-server
```

Inside a Claude Code session, check status with:

```
/mcp
```

This shows which servers are connected, which have errors, and lets you restart them.

## Decision Framework: Which Server Do I Need?

Before adding an MCP server, ask yourself:

| Question | If yes... | If no... |
| :-- | :-- | :-- |
| Can I do this with a shell command? | Use the shell | Consider MCP |
| Will I use this tool more than 3 times this session? | Worth the context cost | Probably not |
| Does the whole team need this? | Add to `.mcp.json` | Keep it personal |
| Am I already near context limits? | Skip it, use the shell | Go ahead |

**Common servers and when they make sense:**

| Server | Good for | Skip when... |
| :-- | :-- | :-- |
| Filesystem | Scoped file access across directories | You're working in one project |
| Database (Postgres, SQLite) | Schema exploration, query testing | You rarely touch the DB |
| Browser | Web scraping, testing | Simple curl would work |
| GitHub | PR workflows, issue management | You prefer the `gh` CLI |

## Project-Shared vs. Personal Servers

MCP servers live in one of two places:

**Project-shared** (`.mcp.json` at project root): Every team member gets these servers automatically. Commit this file to git.

```json
{
  "mcpServers": {
    "postgres": {
      "command": "npx",
      "args": ["@modelcontextprotocol/server-postgres"],
      "env": {
        "DATABASE_URL": "postgresql://localhost:5432/mydb"
      }
    }
  }
}
```

**Personal** (user config at `~/.claude/`): Only you get these. Use for servers tied to your local setup or personal tools.

<Callout title="Key Insight">
Treat `.mcp.json` like you treat `.eslintrc`. It defines shared tooling conventions. Personal preferences go in your user config.
</Callout>

## Try It Yourself

<Steps>
  <Step>
    **Audit your current setup.** Run `claude mcp list` and count how many servers you have enabled. If it's more than four, consider which ones you haven't used recently and remove them.
  </Step>
  <Step>
    **Add a server intentionally.** Pick one server that would genuinely help your current project. Add it with `claude mcp add`, use it for a task, then check `/cost` to see the context impact.
  </Step>
  <Step>
    **Create a `.mcp.json`.** If your project doesn't have one yet, create a minimal config with just the one or two servers your whole team would benefit from. Commit it and ask a teammate to verify it works.
  </Step>
</Steps>

## What You Learned

- **MCP connects external tools** (databases, browsers, APIs) to Claude Code through a standardized protocol.
- **Every enabled server costs context**, even when idle. Keep 2-4 servers per project.
- **Prefer shell commands** over MCP when the task is simple enough.
- **Project-shared servers** go in `.mcp.json` (committed to git). Personal servers go in your user config.
- **Audit regularly.** Remove servers you haven't used recently to keep context lean.
