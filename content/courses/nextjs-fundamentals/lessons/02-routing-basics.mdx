---
title: "Routing Basics"
description: "Understand file-based routing, dynamic segments, and how layouts compose in the App Router."
playbackId: ""
access: "public"
order: 2
module: "Getting Started"
---

## File-Based Routing

The App Router uses your file system as the routing API. This isn't just convenient—it's a fundamental design decision that makes routes predictable and discoverable.

### Route Segments

Every folder in `app/` becomes a route segment:

```
app/
├── page.tsx           # /
├── about/
│   └── page.tsx       # /about
└── blog/
    ├── page.tsx       # /blog
    └── [slug]/
        └── page.tsx   # /blog/any-slug
```

### Dynamic Routes

Square brackets create dynamic segments that capture URL parameters:

```tsx
// app/blog/[slug]/page.tsx
export default async function BlogPost({
  params
}: {
  params: Promise<{ slug: string }>
}) {
  const { slug } = await params;

  return <article>Post: {slug}</article>;
}
```

### Layouts and Nesting

Layouts wrap their children and persist across navigations. This is powerful for:

- Shared navigation and sidebars
- Preserving state during route changes
- Reducing unnecessary re-renders

```tsx
// app/blog/layout.tsx
export default function BlogLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <div className="flex">
      <aside>Sidebar</aside>
      <main>{children}</main>
    </div>
  );
}
```

### Navigation

Use the `Link` component for client-side navigation:

```tsx
import Link from "next/link";

<Link href="/blog">Blog</Link>
<Link href={`/blog/${post.slug}`}>{post.title}</Link>
```

Next, we'll explore how Server Components change the way we fetch data.
